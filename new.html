<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP Methods: The Web's Secret Language</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        :root {
            /* Deeper, more aesthetic matte colors */
            --background-color: #171c26;
            --card-bg: #212833;
            --text-color: #aeb9be;
            --primary-color: #38bdf8;
            --accent-color: #81e6d9;
            
            /* More distinct, muted colors for each HTTP method */
            --get-color: #65a30d; /* Vibrant Green */
            --post-color: #c084fc; /* Cool Purple */
            --put-color: #f59e0b; /* Warm Orange */
            --delete-color: #ef4444; /* Strong Red */
            --patch-color: #22d3ee; /* Aqua Blue */
            --head-color: #d8b4fe; /* Light Purple */
            --trace-color: #a78bfa; /* Deeper Purple */
            --connect-color: #fb7185; /* Soft Pink */
            --submit-color: #2563eb;
            --code-bg: #1e242e;
            --url-bg: #2d3440;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header {
            width: 100%;
            background: linear-gradient(to bottom right, #2563eb, var(--primary-color));
            color: white;
            text-align: center;
            padding: 2.5rem 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 2rem;
            border-bottom-right-radius: 2rem;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            color: white;
        }
        
        .header p {
            font-size: 1.25rem;
            font-weight: 300;
            opacity: 0.8;
            color: white;
        }
        
        .main-container {
            padding: 2rem;
            margin: 0 auto;
            max-width: 1280px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        
        .section-card {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .section-card h2 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 0.75rem;
            margin-bottom: 1.5rem;
        }
        
        .intro-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1.5rem 0;
            gap: 2rem;
        }
        
        .intro-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            color: var(--primary-color);
        }

        .intro-icon i {
            font-size: 6rem;
            padding: 1rem;
            border: 4px solid var(--primary-color);
            border-radius: 50%;
        }
        
        .intro-icon span {
            margin-top: 0.75rem;
            font-weight: 600;
            color: white;
        }
        
        .intro-arrow {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-color);
        }
        
        .method-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
        }
        
        .method-card {
            background-color: #272f3d;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 2px solid;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .method-card:hover {
            transform: translateY(-5px);
        }
        
        .method-card.get { border-color: var(--get-color); }
        .method-card.post { border-color: var(--post-color); }
        .method-card.put { border-color: var(--put-color); }
        .method-card.delete { border-color: var(--delete-color); }
        .method-card.patch { border-color: var(--patch-color); }
        .method-card.head { border-color: var(--head-color); }
        .method-card.trace { border-color: var(--trace-color); }
        .method-card.connect { border-color: var(--connect-color); }

        .method-card h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .method-card h3 i {
            font-size: 1.25rem;
        }

        .method-card ul {
            list-style-type: 'ðŸ‘‰';
            padding-left: 1.5rem;
            margin-top: 1rem;
            line-height: 1.5;
        }
        
        .method-card li {
            padding-left: 0.5rem;
        }
        
        .method-card strong {
            color: var(--accent-color);
        }
        
        .drag-game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }
        
        .scenarios-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            width: 100%;
        }
        
        .scenario-card {
            background-color: var(--primary-color);
            padding: 1rem;
            border-radius: 0.75rem;
            border: 2px solid var(--accent-color);
            cursor: grab;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            color: var(--background-color);
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            text-align: center;
        }
        
        .scenario-card:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .scenario-card:active {
            cursor: grabbing;
        }
        
        .drop-zones-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            width: 100%;
        }
        
        .drop-zone {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            border: 4px dashed var(--text-color);
            text-align: center;
            transition: all 0.2s ease-in-out;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .drop-zone.border-solid {
            border-style: solid;
            border-color: var(--primary-color);
            box-shadow: 0 0 15px var(--primary-color);
        }
        
        .drop-zone h4 {
            font-size: 1.5rem;
            color: var(--primary-color);
        }
        
        .success-message {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-top: 1rem;
        }
        
        .game-section {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--text-color);
        }
        
        .game-section h2 {
            color: var(--accent-color);
            border-bottom: 2px solid var(--accent-color);
        }
        
        .game-controls {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        
        .game-btn, .start-btn, .quit-btn, .play-again-btn {
            font-weight: 700;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            border: none;
            color: #1a202c;
        }
        
        .game-btn:hover, .start-btn:hover, .quit-btn:hover, .play-again-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }
        
        .game-area {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 1rem;
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .timer-bar {
            width: 100%;
            height: 0.75rem;
            background-color: #4b5563;
            border-radius: 9999px;
            margin-bottom: 1.5rem;
        }
        
        .timer-progress {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 9999px;
            transition: width 0.1s linear;
        }
        
        .request-prompt {
            background-color: var(--primary-color);
            color: var(--background-color);
            font-size: 1.5rem;
            font-weight: 700;
            padding: 1.5rem;
            border-radius: 0.75rem;
            text-align: center;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .game-buttons-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-top: 1.5rem;
            width: 100%;
        }

        .game-buttons-grid .game-btn {
            background-color: var(--primary-color);
            color: var(--background-color);
            font-weight: bold;
            font-size: 1rem;
        }
        
        .game-btn {
            padding: 1rem;
        }
        
        #get-btn { background-color: var(--get-color); }
        #post-btn { background-color: var(--post-color); }
        #put-btn { background-color: var(--put-color); }
        #delete-btn { background-color: var(--delete-color); }
        #patch-btn { background-color: var(--patch-color); }
        #head-btn { background-color: var(--head-color); }
        #trace-btn { background-color: var(--trace-color); }
        #connect-btn { background-color: var(--connect-color); }

        #quit-btn {
            background-color: var(--card-bg);
            color: var(--text-color);
            margin-top: 1rem;
            width: 100%;
        }
        
        .feedback-area {
            background-color: #374151;
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin-top: 1.5rem;
            width: 100%;
        }
        
        .feedback-area h3 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }
        
        .feedback-area p {
            color: #d1d5db;
        }
        
        .game-over-message {
            text-align: center;
            margin-top: 1.5rem;
        }
        
        .game-over-message p {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .game-over-message #score-text {
            font-size: 1.25rem;
            margin-top: 0.5rem;
        }
        
        .game-over-message #high-score-message {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--accent-color);
            margin-top: 0.25rem;
        }
        
        .play-again-btn {
            margin-top: 1rem;
            background-color: var(--primary-color);
            color: var(--background-color);
        }
        
        .hidden {
            display: none;
        }
        
        .opacity-50 {
            opacity: 0.5;
        }
        
        .pointer-events-none {
            pointer-events: none;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }

        /* --- New Method Details Section Styles --- */
        .method-details-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .method-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            background-color: #272f3d;
            padding: 2.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
        }

        .method-selector h3 {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .method-selector select {
            background-color: #374151;
            border: 2px solid transparent;
            border-radius: 0.75rem;
            padding: 0.75rem 1.5rem;
            font-size: 1rem; /* Smaller font size as requested */
            color: white;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23aeb9be%22%20d%3D%22M287%20164.7c-5.4%205.4-11.8%208.1-19%208.1-7.2%200-13.6-2.7-19-8.1L146.2%2075.7%2050.6%20171.3c-5.4%205.4-11.8%208.1-19%208.1s-13.6-2.7-19-8.1c-10.9-10.9-10.9-28.4%200-39.3l126.3-126.3L287%20125.4c10.9%2010.9%2010.9%2028.4%200%2039.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 1em top 50%;
            background-size: 0.65em auto;
        }
        
        .method-selector select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.5);
        }

        .method-explanation-area {
            background-color: #1f2530;
            padding: 1.5rem 2rem;
            border-radius: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            line-height: 1.6;
        }
        
        .method-explanation-area h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 0.75rem;
        }
        
        .method-explanation-area p {
            font-size: 1rem;
            color: var(--text-color);
            margin-bottom: 1rem;
        }
        
        .code-container {
            background-color: var(--code-bg);
            padding: 1.5rem;
            border-radius: 1rem;
            margin-top: 1rem;
        }
        
        .code-container h4 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .code-block {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            color: #ccc;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
            padding: 0;
            margin: 0;
        }

        /* --- New Practical Demo Styles --- */
        .practical-demo {
            margin-top: 2rem;
            border-top: 2px solid var(--card-bg);
            padding-top: 2rem;
        }

        .practical-demo h4 {
            font-size: 1.5rem;
            color: var(--accent-color);
            margin-bottom: 1rem;
        }

        .practical-controls {
            display: flex;
            gap: 1rem;
            flex-direction: column;
            margin-bottom: 1.5rem;
        }

        .practical-controls label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            display: block;
        }

        .practical-controls input, .practical-controls textarea {
            width: 100%;
            padding: 0.75rem;
            background-color: #2d3440;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
            color: white;
            font-family: 'Inter', sans-serif;
            resize: vertical;
        }
        
        #send-request-btn {
            background-color: var(--submit-color);
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.2s;
            align-self: flex-start;
        }

        #send-request-btn:hover {
            background-color: #1d4ed8;
        }

        .response-area {
            background-color: #1e242e;
            padding: 1.5rem;
            border-radius: 1rem;
        }

        .response-area h5 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .response-area pre {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            color: #ccc;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

    </style>
</head>
<body>

    <div class="header">
        <h1>HTTP Methods: The Web's Secret Language</h1>
        <p>A fun and interactive guide to GET vs. POST and beyond!</p>
    </div>

    <main class="main-container">
        <!-- Introduction Section -->
        <section class="section-card">
            <h2>Your Web Browser is a Busy Restaurant</h2>
            <p style="font-size: 1.125rem;">
                Imagine your web browser is a customer and a web server is the kitchen. HTTP methods are the different ways you talk to the kitchen.
                You can <strong>ask for the menu</strong>, <strong>order a meal</strong>, or even <strong>cancel an order</strong>. Each action requires a different kind of request.
            </p>
            <div class="intro-container">
                <div class="intro-icon">
                    <i class="fas fa-laptop-code"></i>
                    <span>Your Browser</span>
                </div>
                <div class="intro-arrow">&harr;</div>
                <div class="intro-icon">
                    <i class="fas fa-server"></i>
                    <span>The Web Server</span>
                </div>
            </div>
        </section>

        <!-- Main HTTP Methods Section -->
        <section class="section-card">
            <h2>The HTTP Crew: Main to Specialized</h2>
            <div class="method-container">
                <!-- GET Card -->
                <div class="method-card get">
                    <h3><i class="fas fa-search"></i> GET</h3>
                    <p>Request data from a specified resource. It's like asking for a menu item's details. These requests are <strong>safe</strong> and <strong>idempotent</strong>, meaning they don't change server state and can be repeated.</p>
                </div>
                <!-- POST Card -->
                <div class="method-card post">
                    <h3><i class="fas fa-upload"></i> POST</h3>
                    <p>Send data to the server to create a new resource. This is like placing a new order. They are <strong>not idempotent</strong>, so submitting the same request twice might create two resources.</p>
                </div>
                <!-- PUT Card -->
                <div class="method-card put">
                    <h3><i class="fas fa-sync-alt"></i> PUT</h3>
                    <p>Replace all current representations of the target resource with the request payload. This is a full update to a resource, like replacing an entire order with a new one.</p>
                </div>
                <!-- DELETE Card -->
                <div class="method-card delete">
                    <h3><i class="fas fa-trash-alt"></i> DELETE</h3>
                    <p>Request to delete a specified resource. Like canceling an order, this method removes a resource from the server.</p>
                </div>
                <!-- PATCH Card -->
                <div class="method-card patch">
                    <h3><i class="fas fa-pen-nib"></i> PATCH</h3>
                    <p>Apply partial modifications to a resource. This is for small, partial updates, like asking for a minor change to your meal without replacing the whole thing.</p>
                </div>
                <!-- HEAD Card -->
                <div class="method-card head">
                    <h3><i class="fas fa-info-circle"></i> HEAD</h3>
                    <p>Request headers of a resource, without the body. It's a lightweight way to check if a file exists or its metadata before downloading the full content.</p>
                </div>
                <!-- TRACE Card -->
                <div class="method-card trace">
                    <h3><i class="fas fa-route"></i> TRACE</h3>
                    <p>Perform a message loop-back test along the path to the target resource. This is for diagnostics, allowing the client to see what the server receives after any intermediate proxy modifications.</p>
                </div>
                <!-- CONNECT Card -->
                <div class="method-card connect">
                    <h3><i class="fas fa-link"></i> CONNECT</h3>
                    <p>Establish a tunnel to the server identified by the target resource. This is primarily used for creating secure HTTPS tunnels through an unencrypted HTTP proxy.</p>
                </div>
            </div>
        </section>

        <!-- Real-life Examples Section -->
        <section class="section-card">
            <h2>Ordering a Pizza: A Real-World Analogy</h2>
            <p style="font-size: 1.125rem;">
                Let's use a common online taskâ€”ordering a pizzaâ€”to see how these methods work in practice. Every click and form submission is an HTTP request!
            </p>
            <div class="method-container" style="margin-top: 1.5rem;">
                <div class="method-card get">
                    <h3><strong>GET</strong>: Looking at the menu</h3>
                    <p>When you click on the "menu" page, your browser sends a <strong>GET</strong> request to the server. It's asking the server for the latest list of pizzas, toppings, and prices.</p>
                </div>
                <div class="method-card post">
                    <h3><strong>POST</strong>: Submitting your order</h3>
                    <p>When you fill out your name, address, and select your pizza, then click "Place Order," your browser bundles all that data and sends it with a <strong>POST</strong> request. This tells the server to create a new order in their database.</p>
                </div>
                <div class="method-card put">
                    <h3><strong>PUT</strong>: Changing your mind completely</h3>
                    <p>You submitted a pizza order, but then you realize you wanted a different pizza entirely. You go to your "My Orders" page, change the pizza, and hit "Update." This sends a <strong>PUT</strong> request that <em>replaces</em> your old order with a brand-new one.</p>
                </div>
                <div class="method-card patch">
                    <h3><strong>PATCH</strong>: Adding an extra topping</h3>
                    <p>You forgot to add extra cheese! You call the restaurant and say, "Can you just add one more topping to my order?" This is like a <strong>PATCH</strong> requestâ€”it's a small, partial update to an an existing resource, not a full replacement.</p>
                </div>
                <div class="method-card delete">
                    <h3><strong>DELETE</strong>: Canceling your order</h3>
                    <p>Oops, you accidentally ordered two pizzas. You call the restaurant and ask them to cancel the extra one. This action sends a <strong>DELETE</strong> request, which tells the server to permanently remove that specific order from the system.</p>
                </div>
            </div>
        </section>

        <!-- Interactive Activity Section -->
        <section class="section-card">
            <h2>Activity: Method Mingle!</h2>
            <p style="font-size: 1.125rem; margin-bottom: 1rem;">Drag each scenario card to the correct box to test your knowledge.</p>
            <div class="drag-game-container">
                <div id="scenarios" class="scenarios-list">
                    <div class="scenario-card" draggable="true" data-method="GET">Searching for a new recipe.</div>
                    <div class="scenario-card" draggable="true" data-method="POST">Saving a review for a restaurant.</div>
                    <div class="scenario-card" draggable="true" data-method="GET">Viewing today's special on a website.</div>
                    <div class="scenario-card" draggable="true" data-method="POST">Paying for your meal.</div>
                    <div class="scenario-card" draggable="true" data-method="GET">Checking the delivery status of your order.</div>
                    <div class="scenario-card" draggable="true" data-method="POST">Filling out a form for a reservation.</div>
                </div>
                <div class="drop-zones-container">
                    <div id="get-zone" class="drop-zone get-zone">
                        <h4>GET</h4>
                    </div>
                    <div id="post-zone" class="drop-zone post-zone">
                        <h4>POST</h4>
                    </div>
                </div>
                <p id="success-message" class="success-message hidden">Excellent! You got them all right!</p>
            </div>
        </section>

        <!-- The Game Section -->
        <section class="game-section">
            <h2>Game: The HTTP Dispatcher</h2>
            <p style="font-size: 1.125rem;">You're a server! Read the incoming request and quickly click the correct button to process it. Don't be too slow!</p>
            <div id="game-controls" class="game-controls">
                <button id="main-start-button" class="start-btn">Start Game</button>
            </div>

            <div id="game-area" class="game-area hidden">
                <div class="game-stats">
                    <span id="game-score">Score: 0</span>
                    <span id="high-score">High Score: 0</span>
                </div>
                <div class="timer-bar">
                    <div id="timer-progress" class="timer-progress"></div>
                </div>
                <div id="request-prompt" class="request-prompt"></div>
                
                <div class="game-buttons-grid">
                    <button id="get-btn" class="game-btn">GET</button>
                    <button id="post-btn" class="game-btn">POST</button>
                    <button id="put-btn" class="game-btn">PUT</button>
                    <button id="delete-btn" class="game-btn">DELETE</button>
                    <button id="patch-btn" class="game-btn">PATCH</button>
                    <button id="head-btn" class="game-btn">HEAD</button>
                    <button id="trace-btn" class="game-btn">TRACE</button>
                    <button id="connect-btn" class="game-btn">CONNECT</button>
                </div>
                <button id="quit-btn" class="quit-btn">Quit Game</button>
            </div>

            <div id="feedback-area" class="feedback-area hidden">
                <h3 id="feedback-title"></h3>
                <p id="feedback-text"></p>
            </div>
            
            <div id="game-over-message" class="game-over-message hidden">
                <p id="game-over-text"></p>
                <p id="score-text"></p>
                <button id="play-again-button" class="play-again-btn">Play Again</button>
            </div>
        </section>
        
        <!-- New Method Details Section -->
        <section class="section-card method-details-section">
            <h2>HTTP Methods in Action: Code and Concepts</h2>
            <div class="method-selector">
                <h3>Select a Method to Learn More</h3>
                <select id="method-select-dropdown">
                    <option value="get" selected>GET</option>
                    <option value="post">POST</option>
                    <option value="put">PUT</option>
                    <option value="delete">DELETE</option>
                    <option value="patch">PATCH</option>
                    <option value="head">HEAD</option>
                    <option value="trace">TRACE</option>
                    <option value="connect">CONNECT</option>
                </select>
            </div>
            <div id="method-explanation-area" class="method-explanation-area">
                <!-- Content will be injected here by JavaScript -->
            </div>
        </section>
    </main>
    
    <script>
        // Game State and functions
        let score = 0;
        let highScore = 0;
        let timer;
        let timeRemaining = 5;
        let gameRunning = false;
        let currentRequest = {};
        let questionCount = 0;
        let shuffledRequests = [];

        const gameRequests = [
            { prompt: 'Reading an article on a blog', method: 'GET', correct: 'GET', explanation: "You're just fetching data to read it, which is the main job of the GET method. Itâ€™s like glancing at the specials boardâ€”you don't change anything!" },
            { prompt: 'Submitting a search query', method: 'GET', correct: 'GET', explanation: "A search query is a request for information. You're simply asking the server for data to show you, which is a classic GET request." },
            { prompt: 'Sending a message in a chat app', method: 'POST', correct: 'POST', explanation: "Sending a message is like placing an order! You're creating new data on the server, so POST is needed. You're adding something new to the system." },
            { prompt: 'Viewing your profile page', method: 'GET', correct: 'GET', explanation: "Viewing your profile is like looking at the menuâ€”you're just getting information, so it's a GET request. Nothing on the server is being changed." },
            { prompt: 'Logging into your account', method: 'POST', correct: 'POST', explanation: "You're sending private information (your login details) to the server to start a session. This is a classic POST request because you're creating a new state on the server." },
            { prompt: 'Deleting an old photo', method: 'DELETE', correct: 'DELETE', explanation: "To get rid of something on the server, you need the DELETE method. It's the digital equivalent of canceling an order!" },
            { prompt: 'Uploading a new profile picture', method: 'POST', correct: 'POST', explanation: "Uploading a file means you're creating new data on the server, so it's a POST request. Youâ€™re giving the server something new to store." },
            { prompt: 'Updating your password', method: 'PUT', correct: 'PUT', explanation: "When you update your password, you are replacing the old one with a new one. The PUT method is for replacing an entire resource." },
            { prompt: 'Browsing a product category', method: 'GET', correct: 'GET', explanation: "You're just fetching a list of products to see them. This is a GET request because you aren't changing anything." },
            { prompt: 'Changing a file name in a document editor', method: 'PUT', correct: 'PUT', explanation: "Changing an existing file means you're replacing it with a new version. The PUT method is for updating an entire resource." },
            { prompt: 'Removing a friend from your list', method: 'DELETE', correct: 'DELETE', explanation: "To get rid of something on the server, you need the DELETE method. It's like removing an item from a list." },
            { prompt: 'Unsubscribing from a newsletter', method: 'DELETE', correct: 'DELETE', explanation: "Unsubscribing means you're removing yourself from a list, which is a DELETE request. You are requesting the server to remove your data." },
            { prompt: 'Submitting a new blog post', method: 'POST', correct: 'POST', explanation: "You're creating a brand new piece of data on the server, which is a key purpose of the POST method." },
            { prompt: 'Adding a new comment to a post', method: 'POST', correct: 'POST', explanation: "You are adding new content to the database. That's a classic POST request." },
            { prompt: 'Liking a social media post', method: 'PUT', correct: 'PUT', explanation: "Liking a post changes the count for that post. It is an update to an existing resource, making it a PUT request." },
            { prompt: 'Checking the server to see if a file exists without downloading it', method: 'HEAD', correct: 'HEAD', explanation: "The HEAD method is perfect for this. It requests the headers, which contain metadata, without requesting the entire resource body." },
            { prompt: 'Using a proxy server to create a secure connection to a website', method: 'CONNECT', correct: 'CONNECT', explanation: "The CONNECT method is specifically designed to establish a tunnel through a proxy server for secure connections, like with HTTPS." },
            { prompt: 'Testing what happens to a request message as it passes through proxies', method: 'TRACE', correct: 'TRACE', explanation: "The TRACE method sends a diagnostic request that gets echoed back to the client, allowing you to see if the message was altered by any intermediate servers." },
            { prompt: 'Changing the title of a post', method: 'PATCH', correct: 'PATCH', explanation: "Changing just the title is a partial update, which is the main use case for the PATCH method." },
            { prompt: 'Changing your profile picture', method: 'POST', 'correct': 'POST', explanation: "You're sending new data to the server to be added to your profile. This is a POST request." },
            { prompt: 'Viewing a list of products in a category', method: 'GET', correct: 'GET', explanation: "You are simply requesting data to view, making it a GET request." },
            { prompt: 'Signing up for a new account', method: 'POST', correct: 'POST', explanation: "You are creating a new resource (your account) on the server, which requires a POST request." },
            { prompt: 'Updating your shipping address', method: 'PUT', correct: 'PUT', explanation: "You are replacing the old shipping address with a new one. This full replacement is a good use of the PUT method." },
        ];
        
        const mainStartButton = document.getElementById('main-start-button');
        const scoreDisplay = document.getElementById('game-score');
        const highScoreDisplay = document.getElementById('high-score');
        const timerProgress = document.getElementById('timer-progress');
        const requestPrompt = document.getElementById('request-prompt');
        const gameArea = document.getElementById('game-area');
        const gameControls = document.getElementById('game-controls');
        const feedbackArea = document.getElementById('feedback-area');
        const feedbackTitle = document.getElementById('feedback-title');
        const feedbackText = document.getElementById('feedback-text');
        const gameOverMessage = document.getElementById('game-over-message');
        const gameOverText = document.getElementById('game-over-text');
        const scoreText = document.getElementById('score-text');
        const playAgainButton = document.getElementById('play-again-button');
        
        const gameButtons = {
            get: document.getElementById('get-btn'),
            post: document.getElementById('post-btn'),
            put: document.getElementById('put-btn'),
            delete: document.getElementById('delete-btn'),
            patch: document.getElementById('patch-btn'),
            head: document.getElementById('head-btn'),
            trace: document.getElementById('trace-btn'),
            connect: document.getElementById('connect-btn'),
            quit: document.getElementById('quit-btn')
        };
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function setupGame() {
            mainStartButton.addEventListener('click', startGame);
            gameButtons.get.addEventListener('click', () => handleChoice('GET'));
            gameButtons.post.addEventListener('click', () => handleChoice('POST'));
            gameButtons.put.addEventListener('click', () => handleChoice('PUT'));
            gameButtons.delete.addEventListener('click', () => handleChoice('DELETE'));
            gameButtons.patch.addEventListener('click', () => handleChoice('PATCH'));
            gameButtons.head.addEventListener('click', () => handleChoice('HEAD'));
            gameButtons.trace.addEventListener('click', () => handleChoice('TRACE'));
            gameButtons.connect.addEventListener('click', () => handleChoice('CONNECT'));
            gameButtons.quit.addEventListener('click', () => gameOver("You quit!"));
            playAgainButton.addEventListener('click', startGame);
        }

        function startGame() {
            score = 0;
            questionCount = 0;
            shuffledRequests = shuffleArray([...gameRequests]);
            updateScore();
            hideGameOverMessage();
            hideFeedback();
            gameRunning = true;
            gameControls.classList.add('hidden');
            gameArea.style.display = 'flex';
            nextRequest();
        }

        function nextRequest() {
            if (!gameRunning) return;
            if (questionCount >= 10) {
                gameOver(`Game Over! You finished all 10 questions.`);
                return;
            }
            currentRequest = shuffledRequests[questionCount];
            requestPrompt.innerHTML = currentRequest.prompt;
            questionCount++;
            resetTimer();
        }

        function resetTimer() {
            clearInterval(timer);
            timeRemaining = 5;
            timerProgress.style.width = '100%';
            timer = setInterval(() => {
                timeRemaining -= 0.1;
                timerProgress.style.width = (timeRemaining / 5) * 100 + '%';
                if (timeRemaining <= 0) {
                    gameOver("Time's up! You were too slow.");
                }
            }, 100);
        }

        function handleChoice(choice) {
            if (!gameRunning) return;
            clearInterval(timer);
            if (choice === currentRequest.method) {
                score += 10;
                updateScore();
                showFeedback("Correct!", "That's exactly right! You're a natural HTTP dispatcher!");
                feedbackArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                setTimeout(() => {
                    hideFeedback();
                    nextRequest();
                }, 2000);
            } else {
                score = Math.max(0, score - 5);
                updateScore();
                requestPrompt.classList.add('animate-shake');
                requestPrompt.addEventListener('animationend', () => {
                    requestPrompt.classList.remove('animate-shake');
                }, { once: true });
                showFeedback("Wrong!", `The correct answer was <strong>${currentRequest.correct}</strong>. <br>${currentRequest.explanation}`);
                feedbackArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                setTimeout(() => {
                    hideFeedback();
                    nextRequest();
                }, 5000);
            }
        }

        function gameOver(message) {
            gameRunning = false;
            clearInterval(timer);
            gameArea.style.display = 'none';
            gameOverMessage.classList.remove('hidden');
            
            gameOverText.textContent = message;
            scoreText.textContent = `Your final score: ${score}`;
            if (score > highScore) {
                highScore = score;
            }
        }

        function updateScore() {
            scoreDisplay.textContent = `Score: ${score}`;
            highScoreDisplay.textContent = `High Score: ${highScore}`;
        }
        
        function showFeedback(title, text) {
            feedbackTitle.textContent = title;
            feedbackText.innerHTML = text;
            feedbackArea.classList.remove('hidden');
        }

        function hideFeedback() {
            feedbackArea.classList.add('hidden');
        }
        
        function hideGameOverMessage() {
            gameOverMessage.classList.add('hidden');
        }
        
        // --- Interactive Activity JavaScript ---
        const scenarios = document.querySelectorAll('.scenario-card');
        const getZone = document.getElementById('get-zone');
        const postZone = document.getElementById('post-zone');
        const successMessage = document.getElementById('success-message');
        let correctDrops = 0;
        const totalScenarios = scenarios.length;
        
        scenarios.forEach(scenario => {
            scenario.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', e.target.dataset.method);
                e.dataTransfer.setData('text/html', e.target.innerHTML);
                e.target.classList.add('opacity-50');
            });
            scenario.addEventListener('dragend', (e) => {
                e.target.classList.remove('opacity-50');
            });
        });

        [getZone, postZone].forEach(zone => {
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('border-solid');
            });
            zone.addEventListener('dragleave', () => {
                zone.classList.remove('border-solid');
            });
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                const droppedMethod = e.dataTransfer.getData('text/plain');
                const droppedElementText = e.dataTransfer.getData('text/html');
                const droppedElement = Array.from(scenarios).find(card => card.innerHTML.trim() === droppedElementText.trim());
                
                if (!droppedElement) {
                    zone.classList.remove('border-solid');
                    return;
                }

                const isCorrect = (zone.id === 'get-zone' && droppedMethod === 'GET') || (zone.id === 'post-zone' && droppedMethod === 'POST');
                
                if (isCorrect) {
                    droppedElement.classList.add('pointer-events-none', 'opacity-50');
                    droppedElement.draggable = false;
                    zone.appendChild(droppedElement);
                    correctDrops++;
                    if (correctDrops === totalScenarios) {
                        successMessage.classList.remove('hidden');
                    }
                } else {
                    droppedElement.classList.add('animate-shake');
                    droppedElement.addEventListener('animationend', () => {
                        droppedElement.classList.remove('animate-shake');
                    }, { once: true });
                }
                zone.classList.remove('border-solid');
            });
        });
        
        // --- New Dynamic Method Details Section ---
        const methodSelectDropdown = document.getElementById('method-select-dropdown');
        const methodExplanationArea = document.getElementById('method-explanation-area');

        const methodDetails = {
            get: {
                title: 'GET: A Request for Information',
                description: 'The **GET** method is used to retrieve data from a server. It is a "safe" method because it should not have any side effects on the server\'s state. GET requests can be bookmarked and are used for data that can be cached.',
                scenario: 'Imagine you want to view a recipe on a website. Your browser sends a GET request to the server to fetch the recipe\'s page.',
                frontendCode: `
// Asynchronous function to fetch data from an API endpoint.
async function getRecipe(recipeId) {
    // The fetch() call makes a GET request by default.
    const response = await fetch(\`/api/recipes?id=\${recipeId}\`); 
    
    // Check if the response was successful (status code 200-299).
    if (!response.ok) {
        // If not, throw an error to be caught later.
        throw new Error('Failed to fetch recipe.');
    }
    
    // Parse the JSON data from the response body.
    const recipeData = await response.json();
    
    // Log the data to the console for a practical example.
    console.log('Recipe Data:', recipeData);
    
    // Return the data for use in the application.
    return recipeData;
}
                `,
                backendCode: `
# Python (Flask) backend to handle the GET request.
from flask import Flask, request, jsonify

app = Flask(__name__)

# This route decorator specifies that this function handles GET requests to '/api/recipes'.
@app.route('/api/recipes', methods=['GET'])
def get_recipe():
    # Get the 'id' query parameter from the URL (e.g., from '?id=123').
    recipe_id = request.args.get('id')
    
    # In a real application, you would query a database for this ID.
    if recipe_id == '123':
        # If found, return the data as a JSON response with a 200 OK status.
        return jsonify({
            'id': '123',
            'title': 'Spicy Tofu Stir-Fry',
            'ingredients': ['Tofu', 'Broccoli', 'Soy Sauce', 'Ginger'],
            'instructions': 'Stir-fry tofu until crispy. Add broccoli and seasonings. Serve hot.'
        })
    else:
        # If the recipe is not found, return a 404 Not Found status with an error message.
        return jsonify({'error': 'Recipe not found'}), 404

if __name__ == '__main__':
    # Run the Flask development server.
    app.run(debug=True)
                `,
                practical: `
<p>Click the button below to simulate fetching recipe data for a recipe with ID "123". The URL will be "<strong>/api/recipes?id=123</strong>".</p>
<div class="practical-controls">
    <button id="send-request-btn">Send GET Request</button>
</div>
<div class="response-area">
    <h5>Simulated Response</h5>
    <pre id="response-output"></pre>
</div>
                `
            },
            post: {
                title: 'POST: Creating a New Resource',
                description: 'The **POST** method is used to submit data to a server to create a new resource. This is used for actions like submitting a form, uploading a file, or creating a new user account. POST requests are not idempotent; submitting the same request multiple times may create multiple identical resources.',
                scenario: 'You are submitting a new blog post. The data you enter in the form is sent to the server with a POST request to create the post.',
                frontendCode: `
// Asynchronous function to create a new post.
async function createPost(postData) {
    // The fetch() call is configured with the POST method.
    const response = await fetch('/api/posts', {
        method: 'POST',
        headers: {
            // Tell the server the request body is JSON.
            'Content-Type': 'application/json'
        },
        // Convert the JavaScript object to a JSON string for the request body.
        body: JSON.stringify(postData)
    });
    
    // Check if the response was successful. POST usually returns 201 Created.
    if (!response.ok) {
        throw new Error('Failed to create post.');
    }
    
    // Parse the JSON data from the response body.
    const newPost = await response.json();
    
    // Log the created post data.
    console.log('New Post Created:', newPost);
    
    return newPost;
}
                `,
                backendCode: `
# Python (Flask) backend to handle the POST request.
from flask import Flask, request, jsonify

app = Flask(__name__)

# This route handles POST requests to '/api/posts'.
@app.route('/api/posts', methods=['POST'])
def create_post():
    # Get the JSON data from the request body.
    data = request.get_json()
    title = data.get('title')
    content = data.get('content')
    
    # In a real app, you would save this new data to a database.
    new_post = {
        'id': 'post-456', # The new unique ID assigned by the server.
        'title': title,
        'content': content,
        'status': 'published'
    }
    # Return the new resource with a 201 Created status code.
    return jsonify(new_post), 201

if __name__ == '__main__':
    app.run(debug=True)
                `,
                practical: `
<p>Enter a title and content for a new blog post and send it to the server. The URL will be "<strong>/api/posts</strong>".</p>
<div class="practical-controls">
    <label for="post-title">Title:</label>
    <input type="text" id="post-title" value="My First Post">
    <label for="post-content">Content:</label>
    <textarea id="post-content" rows="4">This is the content of my brand new blog post.</textarea>
    <button id="send-request-btn">Send POST Request</button>
</div>
<div class="response-area">
    <h5>Simulated Response</h5>
    <pre id="response-output"></pre>
</div>
                `
            },
            put: {
                title: 'PUT: Replacing an Existing Resource',
                description: 'The **PUT** method is used to update an existing resource by completely replacing its content with the data in the request payload. It is idempotent; sending the same PUT request multiple times will have the same effect as sending it once.',
                scenario: 'You need to update your entire user profile, replacing the old data with new information like a changed name and email.',
                frontendCode: `
// Asynchronous function to update an existing profile.
async function updateProfile(userId, profileData) {
    // The fetch() URL includes the resource ID, and the method is set to PUT.
    const response = await fetch(\`/api/users/\${userId}\`, {
        method: 'PUT',
        headers: {
            // Tell the server the request body is JSON.
            'Content-Type': 'application/json'
        },
        // Convert the JavaScript object to a JSON string.
        body: JSON.stringify(profileData)
    });
    
    // Check if the response was successful.
    if (!response.ok) {
        throw new Error('Failed to update profile.');
    }
    
    // Parse the JSON data from the response body.
    const updatedProfile = await response.json();
    
    // Log the updated profile data.
    console.log('Profile Updated:', updatedProfile);
    
    return updatedProfile;
}
                `,
                backendCode: `
# Python (Flask) backend to handle the PUT request.
from flask import Flask, request, jsonify

app = Flask(__name__)

# The URL contains a variable path segment for the user ID.
@app.route('/api/users/<user_id>', methods=['PUT'])
def update_user(user_id):
    # Get the JSON data from the request body.
    data = request.get_json()
    new_name = data.get('name')
    new_email = data.get('email')
    
    # In a real app, you would find the user by ID and replace their data.
    if user_id == 'user123':
        # Return the new resource with a 200 OK status.
        return jsonify({
            'id': user_id,
            'name': new_name,
            'email': new_email,
            'status': 'updated'
        })
    else:
        # If the user is not found, return a 404 Not Found status.
        return jsonify({'error': 'User not found'}), 404

if __name__ == '__main__':
    app.run(debug=True)
                `,
                practical: `
<p>Update a user profile by replacing the existing data. The URL is "<strong>/api/users/user123</strong>".</p>
<div class="practical-controls">
    <label for="put-name">New Name:</label>
    <input type="text" id="put-name" value="Jane Doe">
    <label for="put-email">New Email:</label>
    <input type="text" id="put-email" value="jane.doe@example.com">
    <button id="send-request-btn">Send PUT Request</button>
</div>
<div class="response-area">
    <h5>Simulated Response</h5>
    <pre id="response-output"></pre>
</div>
                `
            },
            delete: {
                title: 'DELETE: Removing a Resource',
                description: 'The **DELETE** method is used to remove a specified resource from the server. It is idempotent, meaning deleting a resource that is already gone will not cause an error or change server state.',
                scenario: 'You want to permanently delete an old photo from your social media account.',
                frontendCode: `
// Asynchronous function to delete a photo.
async function deletePhoto(photoId) {
    // The fetch() URL includes the resource ID, and the method is set to DELETE.
    const response = await fetch(\`/api/photos/\${photoId}\`, {
        method: 'DELETE'
    });
    
    // Check if the response was successful (usually a 200 OK or 204 No Content).
    if (!response.ok) {
        throw new Error('Failed to delete photo.');
    }
    
    // Log a success message since there is often no body in the response.
    console.log('Photo Deleted:', photoId);
}
                `,
                backendCode: `
# Python (Flask) backend to handle the DELETE request.
from flask import Flask, request, jsonify

app = Flask(__name__)

# The URL contains a variable path segment for the photo ID.
@app.route('/api/photos/<photo_id>', methods=['DELETE'])
def delete_photo(photo_id):
    # In a real app, you would remove the photo from the database.
    if photo_id == 'photo987':
        # Return a success message with a 200 OK status.
        return jsonify({'message': f'Photo {photo_id} has been deleted'}), 200
    else:
        # If the photo is not found, return a 404 Not Found status.
        return jsonify({'error': 'Photo not found'}), 404

if __name__ == '__main__':
    app.run(debug=True)
                `,
                practical: `
<p>Simulate deleting a photo with ID "987". The URL is "<strong>/api/photos/photo987</strong>".</p>
<div class="practical-controls">
    <button id="send-request-btn">Send DELETE Request</button>
</div>
<div class="response-area">
    <h5>Simulated Response</h5>
    <pre id="response-output"></pre>
</div>
                `
            },
            patch: {
                title: 'PATCH: Making a Partial Update',
                description: 'The **PATCH** method is used to apply partial modifications to a resource. Unlike PUT, it only sends the data that needs to be changed, which can be more efficient for large resources.',
                scenario: 'You want to change only the title of a blog post, not the entire content.',
                frontendCode: `
// Asynchronous function to partially update a blog post.
async function patchPostTitle(postId, newTitle) {
    // The fetch() URL includes the resource ID, and the method is set to PATCH.
    const response = await fetch(\`/api/posts/\${postId}\`, {
        method: 'PATCH',
        headers: {
            // Tell the server the request body is JSON.
            'Content-Type': 'application/json'
        },
        // Only send the data that needs to be changed.
        body: JSON.stringify({ title: newTitle })
    });
    
    // Check if the response was successful.
    if (!response.ok) {
        throw new Error('Failed to patch post.');
    }
    
    // Parse the JSON data from the response body.
    const updatedPost = await response.json();
    
    // Log the updated post data.
    console.log('Post Patched:', updatedPost);
    
    return updatedPost;
}
                `,
                backendCode: `
# Python (Flask) backend to handle the PATCH request.
from flask import Flask, request, jsonify

app = Flask(__name__)

# The URL contains a variable path segment for the post ID.
@app.route('/api/posts/<post_id>', methods=['PATCH'])
def patch_post(post_id):
    # Get the JSON data from the request body.
    data = request.get_json()
    new_title = data.get('title')

    # In a real app, you would find the post and update only the 'title' field.
    if post_id == 'post-456':
        # Return the partially updated resource with a 200 OK status.
        return jsonify({
            'id': post_id,
            'title': new_title,
            'content': 'Original post content...',
            'status': 'updated'
        })
    else:
        # If the post is not found, return a 404 Not Found status.
        return jsonify({'error': 'Post not found'}), 404

if __name__ == '__main__':
    app.run(debug=True)
                `,
                practical: `
<p>Simulate updating just the title of a post with ID "456". The URL is "<strong>/api/posts/post-456</strong>".</p>
<div class="practical-controls">
    <label for="patch-title">New Title:</label>
    <input type="text" id="patch-title" value="My Updated Post Title">
    <button id="send-request-btn">Send PATCH Request</button>
</div>
<div class="response-area">
    <h5>Simulated Response</h5>
    <pre id="response-output"></pre>
</div>
                `
            },
            head: {
                title: 'HEAD: Getting Headers Only',
                description: 'The **HEAD** method is a "quick look" before you download. It asks for the headers of a resource, without the body. This is useful for checking if a resource exists, its size, or its last modified date without transferring the full content.',
                scenario: 'Your browser checks if a large video file is up to date before trying to download it.',
                frontendCode: `
// Asynchronous function to get file headers.
async function getFileHeaders(fileUrl) {
    // The fetch() call is configured with the HEAD method.
    const response = await fetch(fileUrl, {
        method: 'HEAD'
    });
    
    // Log the response status.
    console.log('Status:', response.status);
    
    // Log the headers of interest. There is no body to read.
    console.log('Content-Type:', response.headers.get('Content-Type'));
    console.log('Content-Length:', response.headers.get('Content-Length'));
}
                `,
                backendCode: `
# Python (Flask) backend to handle the HEAD request.
from flask import Flask, request, jsonify

app = Flask(__name__)

# This route handles HEAD requests.
@app.route('/api/files/<file_id>', methods=['HEAD'])
def head_file(file_id):
    # In a real app, you would check if the file exists and get its metadata.
    if file_id == 'large-video.mp4':
        # The return value includes an empty body and a dictionary of headers.
        return ('', 200, {
            'Content-Type': 'video/mp4',
            'Content-Length': '50000000', # 50 MB example
            'Last-Modified': 'Fri, 26 Aug 2024 12:00:00 GMT'
        })
    else:
        # If the file is not found, return a 404 Not Found status.
        return ('', 404)

if __name__ == '__main__':
    app.run(debug=True)
                `,
                practical: `
<p>Simulate checking the headers of a large video file to see its size. The URL is "<strong>/api/files/large-video.mp4</strong>".</p>
<div class="practical-controls">
    <button id="send-request-btn">Send HEAD Request</button>
</div>
<div class="response-area">
    <h5>Simulated Response</h5>
    <pre id="response-output"></pre>
</div>
                `
            },
            trace: {
                title: 'TRACE: Tracing the Request Path',
                description: 'The **TRACE** method is a diagnostic tool. It sends a request to a server and asks it to reflect the request back to the client. This allows you to see if any intermediate proxies or firewalls are modifying the request before it reaches the server.',
                scenario: 'A network administrator uses TRACE to troubleshoot why a specific request is behaving unexpectedly, suspecting a proxy server is altering the data.',
                frontendCode: `
// Asynchronous function to perform a TRACE request.
async function traceRequest(url) {
    // Note: The fetch() API might not directly support TRACE in all environments
    // or browsers for security reasons. This is a conceptual example.
    const response = await fetch(url, {
        method: 'TRACE'
    });
    
    // Get the response body, which should contain the echoed request headers.
    const tracedRequest = await response.text();
    
    // Log the headers for analysis.
    console.log('Traced Request Headers:', tracedRequest);
}
                `,
                backendCode: `
# Python (Flask) backend to handle the TRACE request.
from flask import Flask, request

app = Flask(__name__)

# This route handles TRACE requests.
@app.route('/api/diagnostic', methods=['TRACE'])
def trace_request():
    # Flask does not natively handle TRACE, but a web server or proxy can.
    # This is a simulation of a server echoing back the request headers.
    headers = '\\n'.join([f'{key}: {value}' for key, value in request.headers.items()])
    # Return a 200 OK status with the echoed headers in the body.
    return f'HTTP/1.1 200 OK\\n{headers}\\n\\n', 200

if __name__ == '__main__':
    app.run(debug=True)
                `,
                practical: `
<p>Simulate sending a diagnostic TRACE request to "<strong>/api/diagnostic</strong>" to see the headers received by the server.</p>
<div class="practical-controls">
    <button id="send-request-btn">Send TRACE Request</button>
</div>
<div class="response-area">
    <h5>Simulated Response</h5>
    <pre id="response-output"></pre>
</div>
                `
            },
            connect: {
                title: 'CONNECT: Creating a Tunnel',
                description: 'The **CONNECT** method is primarily used to establish a network tunnel, often to allow a client to connect to a secure website (HTTPS) through an unencrypted HTTP proxy. It instructs the proxy server to open a direct connection to the destination server on the client\'s behalf.',
                scenario: 'When you try to access a secure banking website from a corporate network that uses an HTTP proxy, the CONNECT method is used to set up the secure channel.',
                frontendCode: `
// The fetch() API cannot directly make a CONNECT request.
// This is typically handled at a lower level by the browser's networking stack
// and a proxy server. This function explains the concept.
function explainConnect() {
    console.log('Client wants to connect to a secure server (e.g., https://bank.com)');
    console.log('1. Client sends a CONNECT request to the proxy server:');
    console.log('   CONNECT bank.com:443 HTTP/1.1');
    console.log('2. The proxy establishes a TCP connection to bank.com on port 443.');
    console.log('3. The proxy responds with "200 Connection established" and sets up a tunnel.');
    console.log('4. The client now sends encrypted HTTPS traffic directly through this tunnel to bank.com.');
}
                `,
                backendCode: `
# Python (Flask) backend to handle the CONNECT request.
# Flask cannot natively handle the CONNECT method as it's for proxy tunnels.
# A web server like Apache or Nginx would handle this.
# The server's role is simply to establish the tunnel.
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/api/connect', methods=['CONNECT'])
def handle_connect():
    # This function will not be reached in a typical Flask setup.
    # The proxy server itself handles the CONNECT request.
    return jsonify({'message': 'CONNECT request received, but handled by the proxy.'}), 200

if __name__ == '__main__':
    app.run(debug=True)
                `,
                practical: `
<p>The **CONNECT** method is a low-level protocol for proxies and cannot be demonstrated with a simple browser fetch call. Instead, click the button to see a simulated log of the connection process.</p>
<div class="practical-controls">
    <button id="send-request-btn">Simulate Connection</button>
</div>
<div class="response-area">
    <h5>Simulated Log</h5>
    <pre id="response-output"></pre>
</div>
                `
            }
        };

        // Function to render content based on selected method
        function renderMethodDetails(method) {
            const data = methodDetails[method];
            if (!data) return;

            methodExplanationArea.innerHTML = `
                <h3>${data.title}</h3>
                <p>${data.description}</p>
                <h4>Real-World Scenario:</h4>
                <p>${data.scenario}</p>
                
                <div class="code-container">
                    <h4>Front-End (JavaScript)</h4>
                    <pre class="code-block">${data.frontendCode.trim()}</pre>
                </div>
                
                <div class="code-container">
                    <h4>Back-End (Python/Flask)</h4>
                    <pre class="code-block">${data.backendCode.trim()}</pre>
                </div>

                <div class="practical-demo">
                    <h4>Try It Yourself!</h4>
                    ${data.practical}
                </div>
            `;
            
            // Re-attach event listener to the new button
            const sendRequestBtn = document.getElementById('send-request-btn');
            if (sendRequestBtn) {
                sendRequestBtn.addEventListener('click', () => runPracticalDemo(method));
            }
        }

        function runPracticalDemo(method) {
            const outputArea = document.getElementById('response-output');
            
            // Clear previous output
            outputArea.textContent = 'Simulating request...';

            // Simulate a delay for a more realistic feel
            setTimeout(() => {
                let responseData;
                let status;
                
                switch (method) {
                    case 'get':
                        responseData = {
                            id: '123',
                            title: 'Spicy Tofu Stir-Fry',
                            ingredients: ['Tofu', 'Broccoli', 'Soy Sauce', 'Ginger'],
                            instructions: 'Stir-fry tofu until crispy. Add broccoli and seasonings. Serve hot.'
                        };
                        status = '200 OK';
                        break;
                    case 'post':
                        const postTitle = document.getElementById('post-title').value;
                        const postContent = document.getElementById('post-content').value;
                        responseData = {
                            id: 'post-456',
                            title: postTitle,
                            content: postContent,
                            status: 'published'
                        };
                        status = '201 Created';
                        break;
                    case 'put':
                        const newName = document.getElementById('put-name').value;
                        const newEmail = document.getElementById('put-email').value;
                        responseData = {
                            id: 'user123',
                            name: newName,
                            email: newEmail,
                            status: 'updated'
                        };
                        status = '200 OK';
                        break;
                    case 'delete':
                        responseData = { message: 'Photo photo987 has been deleted' };
                        status = '200 OK';
                        break;
                    case 'patch':
                        const newTitle = document.getElementById('patch-title').value;
                        responseData = {
                            id: 'post-456',
                            title: newTitle,
                            content: 'Original post content...',
                            status: 'updated'
                        };
                        status = '200 OK';
                        break;
                    case 'head':
                        responseData = {
                            'Status': '200 OK',
                            'Content-Type': 'video/mp4',
                            'Content-Length': '50000000',
                            'Last-Modified': 'Fri, 26 Aug 2024 12:00:00 GMT',
                            'Note': 'No response body is sent with HEAD requests.'
                        };
                        status = '200 OK';
                        break;
                    case 'trace':
                        responseData = {
                            'Request-Method': 'TRACE',
                            'Request-URL': '/api/diagnostic',
                            'Host': 'localhost:3000',
                            'User-Agent': navigator.userAgent,
                            'Accept': '*/*',
                            'Simulated-Note': 'This shows the request as the server received it.'
                        };
                        status = '200 OK';
                        break;
                    case 'connect':
                        responseData = 'Connection established. Secure tunnel created.';
                        status = '200 OK';
                        break;
                }
                
                // Format and display the response
                let formattedOutput = `Status: ${status}\n\n`;
                if (typeof responseData === 'object' && responseData !== null) {
                    formattedOutput += `Body:\n${JSON.stringify(responseData, null, 2)}`;
                } else {
                    formattedOutput += `Body:\n${responseData}`;
                }
                outputArea.textContent = formattedOutput;
            }, 1000);
        }

        // Event listener for dropdown change
        methodSelectDropdown.addEventListener('change', (e) => {
            const selectedMethod = e.target.value;
            renderMethodDetails(selectedMethod);
        });

        window.onload = function() {
            setupGame();
            renderMethodDetails('get'); // Render initial content for GET method
        };
    </script>
</body>
</html>

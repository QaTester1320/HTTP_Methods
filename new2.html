<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP Methods Explained</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f4f8;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-top: 20px;
        }

        p, ul, ol {
            margin-bottom: 15px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #ecf0f1;
            border-left: 5px solid #3498db;
            border-radius: 8px;
        }

        .code-block {
            background-color: #2d2d2d;
            color: #f1f1f1;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }

        .code-block h4 {
            color: #3498db;
            margin-top: 0;
        }

        .interactive-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background-color: #ecf0f1;
            border-radius: 8px;
            border: 1px solid #bdc3c7;
        }

        .interactive-form input,
        .interactive-form button,
        .interactive-form select {
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #bdc3c7;
            font-size: 16px;
            width: 100%;
            box-sizing: border-box;
        }

        .interactive-form button {
            cursor: pointer;
            background-color: #3498db;
            color: #fff;
            border: none;
            transition: background-color 0.3s ease;
        }

        .interactive-form button:hover {
            background-color: #2980b9;
        }

        .result-box {
            margin-top: 20px;
            padding: 20px;
            background-color: #d1f0d1;
            border: 1px solid #27ae60;
            border-radius: 8px;
        }
        
        #interactive-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .comparison h4 {
            margin-top: 0;
            color: #2c3e50;
        }

        .put-post-patch, .get-head {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .put-post-patch div, .get-head div {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            background-color: #ecf0f1;
            border-radius: 8px;
            border: 1px solid #bdc3c7;
        }

        .method-explanation {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .gemini-container {
            margin-top: 20px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
        }
        .gemini-textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ccc;
            resize: vertical;
            font-size: 16px;
            box-sizing: border-box;
        }
        .gemini-result {
            background-color: #ffffff;
            border-left: 4px solid #3498db;
            padding: 15px;
            border-radius: 4px;
            margin-top: 15px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* New Animation Section Styles */
        .animation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background-color: #f0f4f8;
            border-radius: 8px;
            border: 1px solid #bdc3c7;
        }

        .animation-scene {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 200px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 50px;
        }

        .entity {
            width: 100px;
            height: 100px;
            background-color: #2c3e50;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 1.2rem;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .request-box {
            position: absolute;
            left: calc(50% - 50px);
            width: 100px;
            height: 50px;
            background-color: #e74c3c;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: bold;
            opacity: 0;
            transform: translateX(-200px);
        }

        .response-box {
            position: absolute;
            left: calc(50% - 50px);
            width: 100px;
            height: 50px;
            background-color: #2ecc71;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: bold;
            opacity: 0;
            transform: translateX(200px);
        }

        @keyframes sendRequest {
            0% { transform: translateX(-200px); opacity: 0; }
            50% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(200px); opacity: 0; }
        }

        @keyframes sendResponse {
            0% { transform: translateX(200px); opacity: 0; }
            50% { transform: translateX(0); opacity: 1; }
            100% { transform: translateX(-200px); opacity: 0; }
        }

        .animate-request {
            animation: sendRequest 2s ease-in-out forwards;
        }

        .animate-response {
            animation: sendResponse 2s ease-in-out forwards;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>A Deep Dive into HTTP Methods</h1>
            <p>A comprehensive guide to understanding HTTP methods, their differences, and practical applications with JavaScript examples.</p>
        </header>

        <section class="section">
            <h2>Interactive HTTP Method Demonstrator</h2>
            <p>Enter data below to see how different HTTP methods work. The form will simulate a <code>POST</code> request for creation and a <code>PUT</code> request for an update.</p>
            <div class="interactive-form">
                <input type="text" id="postTitle" placeholder="Enter post title">
                <input type="text" id="postBody" placeholder="Enter post body">
                <input type="number" id="postId" placeholder="Enter post ID to update">
                <button onclick="createPost()">Create Post (POST)</button>
                <button onclick="updatePost()">Update Post (PUT)</button>
            </div>
            <div class="result-box" id="resultBox">
                <h3>Result:</h3>
                <pre id="resultOutput"></pre>
            </div>
        </section>

        <section class="section">
            <h2>HTTP Methods in Action: Code and Concepts</h2>
            <p>Select an HTTP method from the dropdown to see its explanation and a side-by-side code example for both the frontend (client) and backend (server), both written in JavaScript.</p>
            <div class="interactive-form">
                <select id="methodSelect" onchange="updateMethodContent()">
                    <option value="GET">GET</option>
                    <option value="POST">POST</option>
                    <option value="PUT">PUT</option>
                    <option value="PATCH">PATCH</option>
                    <option value="DELETE">DELETE</option>
                    <option value="HEAD">HEAD</option>
                    <option value="OPTIONS">OPTIONS</option>
                    <option value="TRACE">TRACE</option>
                </select>
            </div>
            <div id="interactive-section">
                <h3 id="methodTitle">GET Method</h3>
                <p id="methodDescription">The <code>GET</code> method is used to retrieve data from a server. It should not be used for any operation that changes the server's state. It's safe and idempotent.</p>
                <div class="method-explanation">
                    <div class="code-block">
                        <h4>Frontend (Client-side) JavaScript</h4>
                        <pre id="frontendCode"><code>
// Client requests data for post with ID 1
fetch('/api/posts/1')
    .then(response => response.json())
    .then(data => console.log('GET response:', data));
                        </code></pre>
                    </div>
                    <div class="code-block">
                        <h4>Backend (Server-side) JavaScript</h4>
                        <pre id="backendCode"><code>
// A basic mock server to handle a GET request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();
const posts = [{ id: 1, title: 'Example' }];

app.get('/api/posts/:id', (req, res) => {
    const postId = parseInt(req.params.id);
    const post = posts.find(p => p.id === postId);
    if (post) {
        res.status(200).json(post);
    } else {
        res.status(404).json({ message: 'Not Found' });
    }
});

app.listen(3000, () => console.log('Server running on port 3000'));
                        </code></pre>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Animated HTTP Methods Flow</h2>
            <p>Select a method and watch the animated flow of how a request travels from the client to the server and back.</p>
            <div class="interactive-form">
                <select id="animationMethodSelect" onchange="animateMethod()">
                    <option value="GET">GET</option>
                    <option value="POST">POST</option>
                    <option value="PUT">PUT</option>
                    <option value="PATCH">PATCH</option>
                    <option value="DELETE">DELETE</option>
                    <option value="HEAD">HEAD</option>
                    <option value="OPTIONS">OPTIONS</option>
                    <option value="TRACE">TRACE</option>
                </select>
            </div>
            <div class="animation-container">
                <div class="animation-scene">
                    <div class="entity">Client</div>
                    <div id="requestBox" class="request-box"></div>
                    <div id="responseBox" class="response-box"></div>
                    <div class="entity">Server</div>
                </div>
                <div class="result-box" id="animationResultBox">
                    <h3>Animation Log:</h3>
                    <p id="animationStatus">Select a method to begin the animation.</p>
                </div>
            </div>
        </section>

        <section class="section comparison">
            <h2>PUT vs. POST vs. PATCH</h2>
            <div class="put-post-patch">
                <div>
                    <h4>POST</h4>
                    <p><strong>Purpose:</strong> Used to create a new resource on the server.</p>
                    <p><strong>Key characteristic:</strong> It is not idempotent. Sending the same <code>POST</code> request multiple times will create multiple new resources.</p>
                </div>
                <div>
                    <h4>PUT</h4>
                    <p><strong>Purpose:</strong> Used to update an existing resource or create a new one if the URI is known.</p>
                    <p><strong>Key characteristic:</strong> It is idempotent. Sending the same <code>PUT</code> request multiple times will have the same effect as a single request (the resource is replaced with the new data).</p>
                </div>
                <div>
                    <h4>PATCH</h4>
                    <p><strong>Purpose:</strong> Used to apply partial modifications to a resource.</p>
                    <p><strong>Key characteristic:</strong> It is not idempotent. Sending the same <code>PATCH</code> request multiple times may not have the same effect if the resource state changes between requests.</p>
                </div>
            </div>
        </section>

        <section class="section comparison">
            <h2>GET vs. HEAD</h2>
            <div class="get-head">
                <div>
                    <h4>GET</h4>
                    <p><strong>Purpose:</strong> Retrieves a representation of the specified resource.</p>
                    <p><strong>Key characteristic:</strong> The server returns the full response, including the headers and the body containing the resource data.</p>
                </div>
                <div>
                    <h4>HEAD</h4>
                    <p><strong>Purpose:</strong> Retrieves the headers of a resource without the body.</p>
                    <p><strong>Key characteristic:</strong> The server returns only the headers, useful for checking if a resource exists or verifying its size/type without downloading the content.</p>
                </div>
            </div>
        </section>

        <section class="section gemini-container">
            <h2>Ask Gemini About Web Concepts</h2>
            <p>Type any web development concept below and get a detailed explanation from the Gemini API.</p>
            <div class="interactive-form">
                <textarea id="geminiPrompt" class="gemini-textarea" placeholder="e.g., Explain the difference between synchronous and asynchronous JavaScript..."></textarea>
                <button onclick="askGemini()">Ask Gemini</button>
            </div>
            <div id="geminiLoading" style="display: none; text-align: center; margin-top: 15px;">
                <p>Generating explanation...</p>
            </div>
            <div class="gemini-result" id="geminiResult">
                <p>Your explanation will appear here.</p>
            </div>
        </section>
    </div>

    <script>
        // In-memory data store for the interactive form demonstration
        let posts = [
            { id: 1, title: 'First Blog Post', body: 'This is the content of the first post.' },
            { id: 2, title: 'Second Post', body: 'The body of the second post.' }
        ];

        // Functions for the interactive form
        function simulateApiRequest(method, url, data = null) {
            return new Promise(resolve => {
                setTimeout(() => {
                    let response;
                    const id = parseInt(url.split('/')[3]);

                    switch (method) {
                        case 'POST':
                            const newId = posts.length > 0 ? Math.max(...posts.map(p => p.id)) + 1 : 1;
                            const newPost = { id: newId, ...data };
                            posts.push(newPost);
                            response = { status: 201, data: newPost };
                            break;
                        case 'PUT':
                            const index = posts.findIndex(p => p.id === id);
                            if (index !== -1) {
                                posts[index] = { id: id, ...data };
                                response = { status: 200, data: posts[index] };
                            } else {
                                response = { status: 404, data: { message: 'Not Found' } };
                            }
                            break;
                        default:
                            response = { status: 400, data: { message: 'Method not supported' } };
                    }
                    resolve(response);
                }, 500);
            });
        }

        async function createPost() {
            const title = document.getElementById('postTitle').value;
            const body = document.getElementById('postBody').value;
            const output = document.getElementById('resultOutput');
            const resultBox = document.getElementById('resultBox');

            if (!title || !body) {
                output.textContent = 'Please enter both title and body.';
                resultBox.style.backgroundColor = '#f0d1d1';
                resultBox.style.borderColor = '#c0392b';
                return;
            }

            const newPostData = { title, body };
            output.textContent = 'Simulating POST request...';
            const response = await simulateApiRequest('POST', '/api/posts', newPostData);

            output.textContent = `POST request successful!
Status: ${response.status}
New Post: ${JSON.stringify(response.data, null, 2)}`;
            resultBox.style.backgroundColor = '#d1f0d1';
            resultBox.style.borderColor = '#27ae60';
        }

        async function updatePost() {
            const title = document.getElementById('postTitle').value;
            const body = document.getElementById('postBody').value;
            const id = document.getElementById('postId').value;
            const output = document.getElementById('resultOutput');
            const resultBox = document.getElementById('resultBox');

            if (!id) {
                output.textContent = 'Please enter a post ID to update.';
                resultBox.style.backgroundColor = '#f0d1d1';
                resultBox.style.borderColor = '#c0392b';
                return;
            }

            const updatedData = { title, body };
            output.textContent = `Simulating PUT request for post ID ${id}...`;
            const response = await simulateApiRequest('PUT', `/api/posts/${id}`, updatedData);

            output.textContent = `PUT request successful!
Status: ${response.status}
Updated Post: ${JSON.stringify(response.data, null, 2)}`;
            resultBox.style.backgroundColor = '#d1f0d1';
            resultBox.style.borderColor = '#27ae60';
        }

        // Data and functions for the dynamic code examples section
        const methodData = {
            GET: {
                title: "GET Method",
                description: "The <code>GET</code> method is used to retrieve data from a server. It should not be used for any operation that changes the server's state. It's safe and idempotent.",
                frontend: `
// Client requests data for post with ID 1
fetch('/api/posts/1')
    .then(response => response.json())
    .then(data => console.log('GET response:', data));
                `,
                backend: `
// A basic mock server to handle a GET request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();
const posts = [{ id: 1, title: 'Example' }];

app.get('/api/posts/:id', (req, res) => {
    const postId = parseInt(req.params.id);
    const post = posts.find(p => p.id === postId);
    if (post) {
        res.status(200).json(post);
    } else {
        res.status(404).json({ message: 'Not Found' });
    }
});

app.listen(3000, () => console.log('Server running on port 3000'));
                `
            },
            POST: {
                title: "POST Method",
                description: "The <code>POST</code> method is used to send data to the server to create a new resource. It is not idempotent, as sending the same request multiple times will create multiple resources.",
                frontend: `
// Client sends data to create a new post
const newPost = { title: 'New Post', body: 'This is the body.' };
fetch('/api/posts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(newPost)
})
.then(response => response.json())
.then(data => console.log('POST response:', data));
                `,
                backend: `
// A basic mock server to handle a POST request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();
const posts = []; // In a real app, this would be a database

app.post('/api/posts', (req, res) => {
    const newPost = { id: Date.now(), ...req.body };
    posts.push(newPost);
    res.status(201).json(newPost);
});

app.listen(3000, () => console.log('Server running on port 3000'));
                `
            },
            PUT: {
                title: "PUT Method",
                description: "The <code>PUT</code> method is used to update an existing resource or create a new one if it doesn't exist. It is idempotent, meaning multiple identical requests have the same effect as a single one.",
                frontend: `
// Client sends data to replace post with ID 1
const updatedPost = { title: 'Updated Title', body: 'New body content.' };
fetch('/api/posts/1', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(updatedPost)
})
.then(response => response.json())
.then(data => console.log('PUT response:', data));
                `,
                backend: `
// A basic mock server to handle a PUT request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();
const posts = [{ id: 1, title: 'Old Title' }];

app.put('/api/posts/:id', (req, res) => {
    const postId = parseInt(req.params.id);
    const index = posts.findIndex(p => p.id === postId);
    if (index !== -1) {
        posts[index] = { id: postId, ...req.body };
        res.status(200).json(posts[index]);
    } else {
        res.status(404).json({ message: 'Not Found' });
    }
});

app.listen(3000, () => console.log('Server running on port 3000'));
                `
            },
            PATCH: {
                title: "PATCH Method",
                description: "The <code>PATCH</code> method is used to apply partial modifications to a resource. It is not idempotent and should only be used for small, specific updates.",
                frontend: `
// Client sends data to partially update post with ID 1
const partialUpdate = { body: 'Just updating the body.' };
fetch('/api/posts/1', {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(partialUpdate)
})
.then(response => response.json())
.then(data => console.log('PATCH response:', data));
                `,
                backend: `
// A basic mock server to handle a PATCH request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();
const posts = [{ id: 1, title: 'Original', body: 'Original body' }];

app.patch('/api/posts/:id', (req, res) => {
    const postId = parseInt(req.params.id);
    const post = posts.find(p => p.id === postId);
    if (post) {
        Object.assign(post, req.body); // Update only the specified fields
        res.status(200).json(post);
    } else {
        res.status(404).json({ message: 'Not Found' });
    }
});

app.listen(3000, () => console.log('Server running on port 3000'));
                `
            },
            DELETE: {
                title: "DELETE Method",
                description: "The <code>DELETE</code> method is used to delete a specified resource. It is idempotent, as deleting a resource that is already gone has the same result as deleting it the first time.",
                frontend: `
// Client sends request to delete post with ID 1
fetch('/api/posts/1', {
    method: 'DELETE'
})
.then(response => console.log('DELETE response status:', response.status));
                `,
                backend: `
// A basic mock server to handle a DELETE request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();
let posts = [{ id: 1, title: 'To be deleted' }];

app.delete('/api/posts/:id', (req, res) => {
    const postId = parseInt(req.params.id);
    posts = posts.filter(p => p.id !== postId);
    res.status(204).send(); // 204 No Content
});

app.listen(3000, () => console.log('Server running on port 3000'));
                `
            },
            HEAD: {
                title: "HEAD Method",
                description: "The <code>HEAD</code> method is identical to <code>GET</code>, but the server does not return a response body. It is used to get information about a resource, like its headers, without downloading the content.",
                frontend: `
// Client sends HEAD request to check if a post exists and get its metadata
fetch('/api/posts/1', {
    method: 'HEAD'
})
.then(response => {
    console.log('HEAD status:', response.status);
    console.log('Content-Type:', response.headers.get('Content-Type'));
});
                `,
                backend: `
// A basic mock server to handle a HEAD request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();
const posts = [{ id: 1, title: 'Example' }];

app.head('/api/posts/:id', (req, res) => {
    const postId = parseInt(req.params.id);
    const post = posts.find(p => p.id === postId);
    if (post) {
        res.status(200).set('Content-Type', 'application/json').end();
    } else {
        res.status(404).end();
    }
});

app.listen(3000, () => console.log('Server running on port 3000'));
                `
            },
            OPTIONS: {
                title: "OPTIONS Method",
                description: "The <code>OPTIONS</code> method describes the communication options for the target resource. This is often used to check which HTTP methods are supported by a specific URL.",
                frontend: `
// Client sends OPTIONS request to check allowed methods
fetch('/api/posts/1', {
    method: 'OPTIONS'
})
.then(response => {
    const allowedMethods = response.headers.get('Allow');
    console.log('Allowed methods:', allowedMethods);
});
                `,
                backend: `
// A basic mock server to handle a OPTIONS request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();

app.options('/api/posts/:id', (req, res) => {
    res.status(204).set('Allow', 'GET, PUT, PATCH, DELETE').end();
});

app.listen(3000, () => console.log('Server running on port 3000'));
                `
            },
            TRACE: {
                title: "TRACE Method",
                description: "The <code>TRACE</code> method performs a message loop-back test along the path to the target resource, useful for debugging. It echoes the incoming request back to the client.",
                frontend: `
// Client sends TRACE request to trace the path
fetch('/api/posts/1', {
    method: 'TRACE'
})
.then(response => response.text())
.then(text => console.log('TRACE response:', text));
                `,
                backend: `
// A basic mock server to handle a TRACE request
// (Conceptual example using Node.js)
const express = require('express');
const app = express();

app.trace('/api/posts/:id', (req, res) => {
    res.status(200).set('Content-Type', 'message/http').end('Echoing request back');
});

app.listen(3000, () => console.log('Server running on port 3000'));
                `
            }
        };

        function updateMethodContent() {
            const selectElement = document.getElementById('methodSelect');
            const selectedMethod = selectElement.value;
            const data = methodData[selectedMethod];

            document.getElementById('methodTitle').innerText = data.title;
            document.getElementById('methodDescription').innerHTML = data.description;
            document.getElementById('frontendCode').querySelector('code').innerText = data.frontend;
            document.getElementById('backendCode').querySelector('code').innerText = data.backend;
        }

        // --- Animation Functions ---
        function animateMethod() {
            const method = document.getElementById('animationMethodSelect').value;
            const requestBox = document.getElementById('requestBox');
            const responseBox = document.getElementById('responseBox');
            const statusText = document.getElementById('animationStatus');

            // Reset animation
            requestBox.style.animation = 'none';
            responseBox.style.animation = 'none';
            void requestBox.offsetWidth; // Trigger reflow
            void responseBox.offsetWidth;

            requestBox.style.opacity = '0';
            responseBox.style.opacity = '0';
            requestBox.innerText = '';
            responseBox.innerText = '';

            statusText.innerText = `Sending ${method} request...`;

            // Request animation
            setTimeout(() => {
                requestBox.innerText = method;
                requestBox.style.animation = 'sendRequest 2s ease-in-out forwards';
            }, 100);

            // Response animation
            setTimeout(() => {
                const response = getMethodResponse(method);
                responseBox.innerText = response;
                responseBox.style.animation = 'sendResponse 2s ease-in-out forwards';
                statusText.innerText = `Server responded with ${response}!`;
            }, 2100);
        }

        function getMethodResponse(method) {
            switch (method) {
                case 'GET':
                    return '200 OK';
                case 'POST':
                    return '201 Created';
                case 'PUT':
                    return '200 OK';
                case 'PATCH':
                    return '200 OK';
                case 'DELETE':
                    return '204 No Content';
                case 'HEAD':
                    return '200 OK';
                case 'OPTIONS':
                    return '204 No Content';
                case 'TRACE':
                    return '200 OK';
                default:
                    return '...';
            }
        }

        // --- Gemini API Functions ---
        async function askGemini() {
            const prompt = document.getElementById('geminiPrompt').value;
            const resultBox = document.getElementById('geminiResult');
            const loadingIndicator = document.getElementById('geminiLoading');
            
            if (!prompt) {
                resultBox.innerText = 'Please enter a concept to explain.';
                return;
            }

            loadingIndicator.style.display = 'block';
            resultBox.innerText = '';

            const systemPrompt = "You are a world-class web development expert. Provide a concise and clear explanation of the user's query. Use simple language and markdown to format your response, including code blocks for examples if necessary.";
            const userQuery = prompt;
            const apiKey = ""
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            let response = null;
            let retries = 0;
            const maxRetries = 5;
            const initialDelay = 1000;

            while (retries < maxRetries) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        break;
                    } else if (response.status === 429) {
                        const delay = initialDelay * Math.pow(2, retries);
                        retries++;
                        await new Promise(res => setTimeout(res, delay));
                        continue;
                    } else {
                        throw new Error(`API error: ${response.status}`);
                    }
                } catch (error) {
                    resultBox.innerText = `Error: ${error.message}`;
                    loadingIndicator.style.display = 'none';
                    return;
                }
            }

            if (!response || !response.ok) {
                resultBox.innerText = 'Failed to get a response after multiple retries. Please try again later.';
                loadingIndicator.style.display = 'none';
                return;
            }

            const result = await response.json();
            const text = result?.candidates?.[0]?.content?.parts?.[0]?.text || "No explanation found.";
            
            resultBox.innerText = text;
            loadingIndicator.style.display = 'none';
        }

        // Initialize content on page load
        document.addEventListener('DOMContentLoaded', () => {
            updateMethodContent();
        });
    </script>
</body>
</html>
